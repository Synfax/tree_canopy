---
title: "Missing Middle Street Trees"
subtitle: "The second best time for planting."
---

Over the next ten years:

- Plant 62 new street trees per 100 new dwellings

- Invest $1900 per dwelling in public greening

- Grow 155 MCGs of new tree canopy 

```{r, results='hide', warning=FALSE,message=FALSE}
#| echo: false
#| label: load-_common
source("_common.R")
```

```{r, warning=FALSE, message=FALSE}
#| echo: false
#| label: setup-2
grouping = 'SAL_NAME21'
grouping_sf = sal_sf
pretty_group_name = 'Suburb'


sf_use_s2(FALSE)

melbourne <- st_sfc(st_point(c(144.963115,-37.814175)), crs = 7844)

# random_suburb <- grouping_sf[1:2,] %>% st_centroid() %>% select('centroid') %>% st_as_sfc()
# 
# p = c(melbourne, random_suburb)
# 
# lwgeom::st_geod_azimuth(p,)
# 
# random_suburb <- grouping_sf[1:1,] %>% st_centroid() %>% st_cast('POINT')
# 
# rs <- random_suburb %>%
#   mutate(bearing = c(lwgeom::st_geod_azimuth(.), units::set_units(NA, 'degrees')))

random_suburb <- grouping_sf %>% select('SAL_NAME21', 'geometry', 'distance') %>% st_centroid() %>%
  rowwise() %>%
  mutate(lat = st_coordinates(geometry)[1], lng = st_coordinates(geometry)[2])

# 
# point <- st_sfc(st_point(c(random_suburb$lat[1],random_suburb$lng[1])), crs = 7844)
# g1 <- st_sfc(c( melbourne , point ))

# lwgeom::st_geod_azimuth(g1)


# g4 <- g3 %>% mutate(direction = case_when(
#   bearing > 315 || bearing < 45 ~ "North",
#   bearing > 45 && bearing < 135 ~ "East",
#   bearing > 135 && bearing < 225 ~ "South",
#   bearing > 225 && bearing < 315 ~ "West"
# ))


# directions <- random_suburb %>%
#   rowwise() %>%
#   mutate(pt = st_sfc(st_point(c(lat,lng)), crs = 7844)) %>%
#   mutate(bearing = lwgeom::st_geod_azimuth( st_sfc(c(melbourne, pt)) )) %>%
#   mutate(bearing = as.numeric(units::set_units(bearing, "degrees")) )%>%
#   mutate(bearing = ifelse(bearing < 0, 360 + bearing, bearing)) %>%
#   mutate(direction = case_when(
#     bearing > 0 && bearing < 90 ~ "North East",
#     bearing > 90 && bearing < 180 ~ "South East",
#     bearing > 180 && bearing < 270 ~ "South West",
#     bearing > 270 && bearing < 360 ~ "North West"
#   )) %>%
#   rowwise() %>%
#   mutate(direction = ifelse(distance < 7500, "Inner", direction)) %>%
#   select(SAL_NAME21, direction) %>%
#   st_drop_geometry()

```

## Executive summary

Everyone loves trees. The year-round cooling and the shade in the summer, the organic form and the softening of the urban landscape. Not to mention the [real, tangible benefits](/benefits) that a strong tree canopy provides for our city and those who live here. 

People love street trees in particular. Unlike the private trees confined to individual backyards, the benefits of street trees are distributed to everyone. Whether walking the dog, cycling to work, or sitting by the window in the winter sun with your morning coffee—the presence of a robust street tree canopy only improves the day to day of city life.

And so, because street trees are good, YIMBY Melbourne believes we should have more of them. 

This report provides a pathway to increasing both the number of street trees and the overall tree canopy across our city. 

This report has two key goals:

1. To provide an overview of current tree distribution across Melbourne.
2. To provide an evidence-based costing model for increasing tree canopy in the context of densifying Melbourne's missing middle.

We also provide a brief literature review of street trees, informing the costs and considerations that underpin the model.

### Policy context

The Victorian Government is working to deliver around 400,000 new homes across Melbourne's missing middle over the coming decade. In our previous report, _[Missing Middle Housing Targets](https://targets.yimby.melbourne)_, we laid out a demand-driven model to determine where those homes ought to be built. 

Our housing targets model is designed to be responsive to demand, and adjusted year by year—which is a [key difference between our model and the Victorian Government's](https://www.yimby.melbourne/post/housing-targets-aim-high-but-need-demand-to-back-them-up). In lieu of a crystal ball, this report assumes that 400,0000 homes will be delivered across Melbourne's Missing Middle at the 2024 rate for the full decade.  

This report period of growth is exciting new opportunity for Melbourne to grow its street tree canopy, improving amenity and climate outcomes for both current and future residents, and making an important step toward the vision of a more liveable, sustainable, and affordable Melbourne as laid out in [our flagship report, Melbourne's Missing Middle](https://yimby.melbourne/missing-middle).

## The current distribution of trees across Melbourne

```{r, warning = FALSE}
#| echo: false
#| label: full-canopy-map

trees_grouped <- coverage(group = grouping) %>%
  left_join(grouping_sf, by = (grouping)) %>%
  st_set_geometry('geometry') %>%
  dplyr::select(grouping, tree_percentage,distance, geometry, n) %>%
  filter( n > 10) %>%
  rowwise() %>%
  mutate(tree_percentage = round(tree_percentage, 1)) %>%
  mutate(distance = distance / 1000) %>%
  as('Spatial')

grouping = 'sa1_code_2021'
grouping_sf = sa1_sf 

trees_grouped_sa1 <- coverage(group = grouping) %>%
  left_join(grouping_sf, by = (grouping)) %>%
  st_set_geometry('geometry') %>%
  rowwise() %>%
  mutate(tree_percentage = round(tree_percentage, 1)) %>%
  mutate(distance = distance / 1000) %>%
  filter(n > 10)

grouping = 'SAL_NAME21'
grouping_sf = sal_sf
pretty_group_name = 'Suburb'

#bar chart
sd_map = SharedData$new(trees_grouped)
sd_df = SharedData$new(as.data.frame(trees_grouped@data), group = sd_map$groupName())

  #mapCoverage(trees_per_sa2_cw, trees_per_sa2_cw$data()$tree_percentage , 'Greens', 'Tree Coverage (%)')

  #treePal <- colorNumeric(palette = 'Greens', domain = as.data.frame(sd_df$data())$tree_percentage)
  treePal <- colorNumeric(palette = 'Greens', domain = trees_grouped_sa1$tree_percentage)
  
  map <- leaflet(trees_grouped_sa1) %>%
    setView(lng = 144.963115, lat = -37.814175, zoom = 11) %>%
    addProviderTiles('CartoDB.Positron') %>%
    addPolygons(fillColor = ~treePal(tree_percentage),
                fillOpacity = 0.5,
                opacity = 0)  %>%
    addLegend(position = "bottomright",
              pal = treePal,
              values = sd_df$data()$tree_percentage,
              title = 'Tree Coverage (%)')
  
  sf_use_s2(F)
  

  
  map
  
```

Melbourne's densest tree canopy traces our rivers, creeks, and major parks. This makes sense: these are places where a broad and abundant canopy is able to grow. 

As is the case with much of Melbourne's key infrastructure, this chart makes it immediately clear that the west is underserved when compared with the east. Further analysis below demonstrates the social inequities directly associated with tree canopy.


## Tree canopy in the world's most liveable cities

Melbourne constantly appears in the top ten list of the world's most liveable cities. Meanwhile, a relative abundance of trees is a commonly referenced indicator of said liveability.

So what does canopy cover look like in the current list of top ten liveable cities? 

```{r, warning=FALSE, message=FALSE}
#| echo: false
#| fig-cap: "Note: this chart uses LOESS smoothing, as the scatter or line plots have significant variance. Grey bands denote a 95% confidence interval."
cities = c('vienna', 'copenhagen', 'zurich', 'melbourne', 'calgary', 'geneva', 'sydney', 'vancouver', 'osaka', 'auckland')

big_df <- data.frame()

walk(cities, loadFiles)

# big_df = big_df %>%
#   filter(med_cov != 0, mean_cov != 0)

# big_df = big_df %>%
#   mutate(med_cov = 100 * med_cov, mean_cov = 100 * mean_cov)

big_df = big_df %>% as.data.frame()

big_df = big_df %>% filter(cov < 1)

int_comp <- ggplot(big_df, mapping = aes(distance, cov, colour = city, group = city)) +
  xlab("Distance to Centre (m)") +
  ylab("Mean Tree Coverage (%)") +
  labs(title = "Tree Coverage of Major Cities") +
  geom_smooth(method = 'loess') +
  theme_minimal()



ggplotly(int_comp)
  
# mean_plot <- ggplot(big_df, mapping = aes(distance, mean_cov, colour = city, group = city)) +
#   xlab("Distance to Centre (m)") +
#   ylab("Mean Tree Coverage (%)") +
#   labs(title = "Tree Coverage of Major Cities") +
#   geom_smooth(method = 'loess') +
#   theme_minimal()
# 
# median_plot <- ggplot(big_df, mapping = aes(distance, med_cov, colour = city, group = city)) +
#   xlab("Distance to Centre (m)") +
#   ylab("Median Tree Coverage (%)") +
#   labs(title = "Tree Coverage of Major Cities") +
#   geom_smooth(method = 'loess') +
#   theme_minimal()
# 
# ggplotly(mean_plot)
# 
# ggplotly(median_plot)

```
This chart displays the tree canopy coverage of each city, in rings that start in the city centre and move out almost 15km. To see how this data was calculated, you can visit the [methodology page](/model). 

Vienna and Zurich are the clear winners when it comes to tree canopy coverage. 

Meanwhile, Calgary and Osaka have comparably little tree canopy coverage, and Melbourne sits around the middle of the pack. 

But Melbourne deserves to be better than the middle of the pack, which is why this report lays out a model for increasing the city's tree canopy coverage by 10%—all while doubling our population.

# Trees in Melbourne's Missing Middle

Local councils included in this analysis are the 19 included within our previous report: [Missing Middle Housing Targets](https://targets.yimby.melbourne). These are the LGAs where dense development is viable at scale, and where we will therefore need to focus our efforts on maintaining and improving our street tree canopy. 

## Coverage of streets, parks and residential areas

```{r}
#| echo: false
#| label: fig-airquality
#| fig-cap: "Tree coverage by SA2"
#| warning: false

grouping = 'lga_name_2022'
grouping_sf = lga_sf
pretty_group_name = "Local Government Area"

public_exp = expression( zone_code %in% c('PPRZ', 'PCRZ') )
street_exp = expression(zone_short == 'roads')
 resi_exp = expression(zone_short %in% c('General residential', 'Greenfield', 'Low density residential', 'Neighbourhood residential', 'Residential growth'))
 
rural_exp = expression(zone_short == "Rural/regional")
 
other_exp = expression( !(zone_short %in% c('General residential', 'Greenfield', 'Low density residential', 'Neighbourhood residential', 'Residential growth', 'roads', 'Rural/regional')) && !(zone_code %in% c('PPRZ', 'PCRZ') ))
  

create_combined_df <- function(grouping, grouping_sf) {
  
  
  street_trees_grouped <- coverage(exp = street_exp, type = 'street', group = grouping) %>%
  rename("street_tree_coverage" = coverage, "total_street_area" = total_area )

  reserve_trees_grouped <- coverage(exp = public_exp, type = 'reserve', group = grouping)  %>%
    rename("reserve_tree_coverage" = coverage, "total_reserve_area" = total_area ) 
 
  resi_trees_grouped <- coverage(exp = resi_exp , type = 'residential', group = grouping)  %>%
    rename("residential_tree_coverage" = coverage, "total_residential_area" = total_area )
  
  rural_trees_grouped <- coverage(exp = rural_exp , type = 'rural', group = grouping)  %>%
    rename("rural_tree_coverage" = coverage, "total_rural_area" = total_area )
  
  
  other_trees_grouped <- coverage(exp = other_exp, group = grouping, type = 'other') %>%
    rename('other_tree_coverage' = coverage, 'total_other_area' = total_area)
  
  # street_agg =agg_df %>% filter(eval(street_exp)) %>% filter(lga_name_2022 == 'Banyule')
  # resi_agg= agg_df %>% filter(eval(resi_exp))%>% filter(lga_name_2022 == 'Banyule') 
  # public_agg= agg_df %>% filter(eval(public_exp))%>% filter(lga_name_2022 == 'Banyule')
  # other_agg =agg_df %>% filter(eval(other_exp))%>% filter(lga_name_2022 == 'Manningham')
  
  
  #xzz <- xz %>% left_join(trees_grouped_lga, by = 'lga_name_2022')
  
  # 
  # frame <- bind_rows(
  #   street_agg, resi_agg, public_agg,other_agg
  # )
  # 
  # hasShared = function(df1, df2) {
  #   
  #   df1 = other_agg
  #   df2 = public_agg
  #   
  #   df1n = nrow(df1)
  #   df2n = nrow(df2)
  #   
  #   cmb = bind_rows(df1,df2)
  #   
  #   n_dist_cmb = n_distinct(cmb)
  #   
  #   bl = (n_dist_cmb != (df1n + df2n))
  #   
  #   if(bl) {
  #     
  #   }
  #   
  # }
  # 
 # agg_sf %>% 
 #   group_by(lon, lat) %>%
 #   filter(n() > 1) %>% st_write('fkd.shp')
 # 
 # agg_results %>% group_by(lon, lat) %>%
 #   filter(n() > 1) %>% v()
  
  #combine into one and clean
  combined_df <- street_trees_grouped %>%
    left_join(reserve_trees_grouped, by = grouping) %>%
    left_join(resi_trees_grouped, by = grouping) %>%
    left_join(other_trees_grouped, by = grouping) %>%
    left_join(rural_trees_grouped, by = grouping) %>%
    replace(is.na(.), 0) %>%
    group_by(!!as.name(grouping)) %>%
    mutate(total_area =  sum(across(ends_with('_area'))))  %>%
    mutate(total_coverage_area = sum(across(ends_with('_coverage')))) %>%
    mutate(total_coverage_pc = total_coverage_area / total_area ) %>%
    mutate( weighted_street_pc = (street_tree_coverage / total_coverage_area) * total_coverage_pc,
            weighted_reserve_pc = (reserve_tree_coverage / total_coverage_area) * total_coverage_pc,
            weighted_rural_pc = (rural_tree_coverage / total_coverage_area) * total_coverage_pc,
            weighted_resi_pc = (residential_tree_coverage / total_coverage_area) * total_coverage_pc,
            weighted_other_pc = (other_tree_coverage / total_coverage_area) * total_coverage_pc,
          ) %>%
    dplyr::select(c(grouping,'street_percentage', 'rural_percentage', 'reserve_percentage', 'residential_percentage', 'weighted_street_pc', 'weighted_reserve_pc', 'weighted_rural_pc', 'weighted_resi_pc', 'total_coverage_pc', 'other_percentage', 'weighted_other_pc')) %>%
    left_join(grouping_sf %>% st_drop_geometry() %>% select(grouping, distance), by = grouping) %>%
    rowwise() %>%
    # mutate(distance = distance_map[as.character(as.name(grouping))]) %>%
    mutate(distance = distance / 1000) %>%
    ungroup() %>%
    as.data.frame() %>%
    return()
    # mutate(across(where(is.numeric), ~ round(.x, 1))) %>%
    # mutate(across(ends_with('percentage'), ~ ifelse(is.na(.x), 0, .x) )) %>%
    
}

combined_df = create_combined_df(grouping, grouping_sf)


sd_combined = SharedData$new((combined_df))

```


```{r}
#| echo: false
#| 
combined_longer <- pivot_longer(combined_df,
                                cols = c('weighted_street_pc', 'weighted_reserve_pc', 'weighted_resi_pc', 'weighted_other_pc', 'weighted_rural_pc'),
                                names_to = 'weights',
                                values_to = "test")

stacked_chart <- ggplot(combined_longer, aes(fill=weights, y = test, x= reorder(!!as.name(grouping), test) )) + 
    geom_bar(position="stack", stat="identity") +
  ylab('Total tree coverage (%)') +
  xlab (pretty_group_name) +
  labs( fill = 'Land type') +
  scale_x_discrete(guide = guide_axis(angle = 0)) +
  scale_fill_manual( values = c('tomato', '#7CAE00', '#619CFF', 'purple', 'grey') ) +
  coord_flip() +
  theme_minimal()

p1 <- plotly_build(stacked_chart)
p1$x$data[[1]]$name = "Other"
p1$x$data[[2]]$name = "Public"
p1$x$data[[3]]$name = "Residential"
p1$x$data[[4]]$name = 'Rural'
p1$x$data[[5]]$name = 'Streets'
p1

```


Here, we break down what proportion of a local government’s tree coverage is on what type of land. The plot above is a stacked bar chart that displays the total tree canopy coverage for each local government area and how the total coverage is split between this report's [five main land classifications](/model).

Manningham's tree coverage is greatly inflated by the existence of the Warrandyte state park. Meanwhile, Brimbank has few trees on any one of its land classifications.

```{r}
#| echo: false

stacked_chart_fill <- ggplot(combined_longer, aes(fill=weights, y = test, x= reorder(!!as.name(grouping), test) )) + 
    geom_bar(position="fill", stat="identity") +
  ylab('Total tree coverage (%)') +
  xlab (pretty_group_name) +
  labs( fill = 'Land type') +
  scale_x_discrete(guide = guide_axis(angle = 0)) +
   scale_fill_manual( values = c('tomato', '#7CAE00', '#619CFF', 'purple', 'grey') ) +
  coord_flip() +
  theme_minimal()

p2 <- plotly_build(stacked_chart_fill)
p2$x$data[[1]]$name = "Other"
p2$x$data[[2]]$name = "Public"
p2$x$data[[3]]$name = "Residential"
p2$x$data[[4]]$name = 'Rural'
p2$x$data[[5]]$name = 'Streets'

p2

```


## Tree coverage and equity

Trees are not just nice to look at—they also provide tangible benefits for people. People with access to street tree canopy are richer for it and, as we'll shortly demonstrate, have access to that canopy because they are richer in the first place.

### 'Leafy' is a euphemism for wealthy suburbs

```{r}
#| echo: false

street_coverage = coverage(exp = street_exp, group = 'SAL_NAME21', type = 'street') %>%
  arrange(desc(street_percentage)) %>%
  slice_head(n = 10)


#ggplot(street_coverage, mapping = aes(x = SAL_NAME21, y = street_percentage)) + geom_bar(stat = 'identity') + theme_minimal()

grouping = 'SAL_NAME21'
grouping_sf = sal_sf
pretty_group_name = 'Suburb'

extra_cols = list()
extra_cols[[grouping]] <- colDef(name = pretty_group_name, filterable = T)


slider <- filter_slider("distance", "Distance to CBD", sd_combined, ~distance, min = 0, max = max(sd_combined$data()$distance), width = '75%')
     
#weird bubble plot  
bubble <- reactable(sd_combined,
          defaultSorted = list('street_percentage' = "desc"),
          defaultColDef = colDef(
            show = F,
  cell = bubble_grid(combined_df, shape = 'circles', colors = c("#EDF8E9", "#006D2C")),
  align = 'center',
  vAlign = 'center'),
  columns = c(list(
                 street_percentage = colDef(name = 'Streets', show = T),
                 reserve_percentage = colDef(name = 'Parks', show = T),
                 residential_percentage = colDef(name = 'Residential'), show = T),extra_cols),
  theme = sandstone(),
  defaultSortOrder = 'desc')

#bubble


# Render a bar chart with a label on the left
bar_chart <- function(label, width = "100%", height = "1rem", fill = "#00bfc4", background = NULL) {
  bar <- div(style = list(background = fill, width = width, height = height))
  chart <- div(style = list(flexGrow = 1, marginLeft = "0.5rem", background = background), bar)
  div(style = list(display = "flex", alignItems = "center"), label, chart)
}

reactable(
  sd_combined,
  defaultSorted = list('street_percentage' = "desc"),
  theme = sandstone(),
  defaultColDef = colDef(show = F),
  columns = list(
    lga_name_2022 = colDef(show = T, name = 'LGA'),
    street_percentage = colDef(show = T,name = "Street Coverage (%)", align = "left", cell = function(value) {
      width <- paste0(value / max(sd_combined$data()$street_percentage) * 100, "%")
      bar_chart(round(value, 1), width = width, fill = "grey", background = "#e1e1e1")
    }),
    residential_percentage = colDef(show = T, name = "Residential Coverage (%)", align = "left", cell = function(value) {
      width <- paste0(value / max(sd_combined$data()$residential_percentage) * 100, "%")
      bar_chart(round(value, 1), width = width, fill = "#619CFF", background = "#e1e1e1")
    }),
    reserve_percentage = colDef(show = T, name = "Public Coverage (%)", align = "left", cell = function(value) {
      width <- paste0(value / max(sd_combined$data()$reserve_percentage) * 100, "%")
      bar_chart(round(value, 1), width = width, fill = "#7CAE00", background = "#e1e1e1")
    }),
    other_percentage = colDef(show = F, name = "Other Coverage (%)", align = "left", cell = function(value) {
      width <- paste0(value / max(sd_combined$data()$other_percentage) * 100, "%")
      bar_chart(round(value, 1), width = width, fill = "tomato", background = "#e1e1e1")
    })
  )
) 

```

There is a clear relationship between public tree coverage and the cost of housing. This is evident in both detached house and unit prices, as well as in rents. This is significant: not only can wealth buy you a large backyard, but it can also buy you direct access to suburbs with greener public realms.

This section shows the interaction between public tree coverage and socioeconomic status. We do this through SEIFA scores and the cost of housing in an area, as depicted by both detached house and unit prices, and median rents. 

::: {.callout-caution collapse="true"}
# About these datasets

Rents are using ABS data, which is only available in ranges. Therefore, median rents are defined as whatever bin the median observation falls into. 

The Census was in 2021, and therefore, rents may have been impacted by COVID-19 migration patterns and may have changed since. This may explain the low rent numbers observed.

House & unit prices are sourced from Neoval.

We have performed this analysis using the ABS’s SA2s from 2021.
:::

### Socio-economic status is linked with higher public tree canopy

Using the ABS product [Socio-Economic Indexes for Areas (SEIFA)](https://www.abs.gov.au/websitedbs/censushome.nsf/home/seifa), we explore the relationship between public tree coverage and socio-economic status of an area.


``` {r, message = FALSE, warning = FALSE}
#| echo: false
# seifa_sa2 = readxl::read_xlsx('../data/seifa_sa2.xlsx', sheet = 'Table 1', skip = 5)
#saveRDS(seifa_sa2, '../r_objects/seifa_sa2.Rdata')
seifa_sa2 = readRDS('../r_objects/seifa_sa2.Rdata') %>%
  rename(sa2_code_2021 = '2021 Statistical Area Level 2  (SA2) 9-Digit Code') %>%
  rename(seifa_score = "Score...3") %>%
  mutate(sa2_code_2021 = as.character(sa2_code_2021)) %>%
  mutate(seifa_score = as.numeric(seifa_score)) %>%
  left_join(sa2_prices, by = "sa2_code_2021") %>%
  filter(!is.na(public_percentage), seifa_score > 800)

seifa_plot <- ggplot(seifa_sa2, mapping = aes(x = seifa_score, y = public_percentage)) +
  geom_point(color = "#006D2C") +
  xlab('SEIFA Score') +
  ylab('Tree Coverage of Public Areas (%)') +
  labs(title = "SEIFA Scores against Public Tree Coverage") + 
  theme_minimal() 

ggplotly(seifa_plot)

```

The results above suggest that the relationship between the two is non-linear, meaning that there are diminishing returns beyond a certain proportion of canopy coverage. 

```{r}
#| echo: false
seifa_log_plot <- ggplot(seifa_sa2, mapping = aes(x = seifa_score, y = log(public_percentage))) +
  geom_point(color = "#006D2C") +
  xlab('SEIFA Score') +
  ylab('Log Tree Coverage of Public Areas (%)') +
  labs(title = "SEIFA Scores against Log Public Tree Coverage") + 
  theme_minimal() 

ggplotly(seifa_log_plot)
```

This is backed up further by the relationship's near-linearity when charted logarithmically, indicating that an increase in public canopy coverage from 10% to 20% is associated with a much larger SEIFA score change than an increase from 40% to 50%.

#### House prices and public tree coverage

Next, we’ll explore the relationship between detached house prices and public tree coverage. As seen below, there is a tangible correlation between the two, as areas with higher house prices tend to have more public tree coverage.


```{r, message=FALSE, warning = FALSE}
#| echo: false
lot_sizes <- agg_df %>%
  filter(zoning_permits_housing == 'Housing permitted') %>%
  group_by(SAL_NAME21) %>%
  summarise(med_lot = median(lot_size, na.rm = TRUE), n = n()) %>%
  rowwise()


rents = readRDS('../r_objects/rents.Rdata') %>%
  manipulateRents(grouping = "sa2") %>%
  rowwise() %>%
  mutate(median_band = gsub('\\$', '', median_band)) %>%
  rename(sa2_code_2021 = "sa2")

public_coverage <- coverage(exp = expression( zone_code %in% c('PPRZ', 'PCRZ') | zone_short == 'roads'), type = 'public', group = grouping) %>% select('SAL_NAME21', 'public_percentage')

public_coverage_sa2 <- coverage(exp = expression( zone_code %in% c('PPRZ', 'PCRZ') | zone_short == 'roads'), type = 'public', group = 'sa2_code_2021') %>% select('sa2_code_2021', 'public_percentage')

# house_price_data = readxl::read_xls('../data/Median-House-Price-3rd-Quarter.xls', skip = 1)[-c(1:5),1:6] 

combined_df = create_combined_df(grouping, grouping_sf)

# house_price_data = house_price_data %>%
#   rowwise() %>%
#   mutate(avg = mean(as.numeric(
#     c(`Jul - Sep 2022...2`,
#       `Oct - Dec 2022`,
#       `Jan - Mar 2023`,
#       `Apr - Jun 2023...5`,
#       `Jul - Sep 2023...6`)), na.rm = TRUE)) %>% 
#   select(SUBURB, avg,) %>%
#   rename(SAL_NAME21 = SUBURB) %>%
#   mutate(SAL_NAME21 = str_to_title(SAL_NAME21)) %>%
#   left_join(combined_df, by = grouping) %>%
#   filter(!is.na(distance), !is.na(avg)) %>%
#   rename(average_house_price = avg) %>%
#   mutate(average_house_price = average_house_price / 10^6) %>%
#   left_join(lot_sizes, by = 'SAL_NAME21') %>%
#   left_join(rents, by = 'SAL_NAME21') %>%
#   left_join(public_coverage, by = 'SAL_NAME21') %>%
#   adf() %>%
#   mutate(median_band = as.factor(median_band)) %>%
#   mutate(within15 = ifelse(distance < 15, T, F))



#house_price_data = house_price_data %>% left_join(directions, by = 'SAL_NAME21')

#missing_suburbs = setdiff(combined_df$SAL_NAME21, house_price_data$SAL_NAME21)
#wtf

# house_interactable = SharedData$new(house_price_data)
# 
# filter_slider("distance", "Distance to CBD", house_interactable, max = 30, ~distance, width = '75%')

# price_street_plot <- ggplot(house_interactable, mapping = aes(x = average_house_price, y = street_percentage, text = SAL_NAME21), axe) + xlab('Average House Price ($m)') + ylab('Street Tree Coverage (%)') + geom_point(color = "#006D2C") + theme_minimal()
# 
# price_residential_plot <- ggplot(house_interactable, mapping = aes(x = average_house_price, y = residential_percentage, text = SAL_NAME21), axe) + xlab('Average House Price ($m)') + ylab('Residential Area Tree Coverage (%)') + geom_point(color = "#006D2C") + theme_minimal()

sa2_public_plot_house <- ggplot(sa2_prices %>% filter(property_type == 'HOUSE'), mapping = aes(x = arithmetic_mean, y = public_percentage, text = sa2_name, stroke = NA, fill = within15), axe) + xlab('Average Detached House Price ($m)') + ylab(' Tree Coverage of Public Areas (%)') + geom_point() + labs(caption = "Source: Neosec") +  theme_minimal()

sa2_public_plot_unit <- ggplot(sa2_prices %>% filter(property_type == 'UNIT'), mapping = aes(x = arithmetic_mean, y = public_percentage, text = sa2_name, stroke = NA, fill = within15), axe) + xlab('Average Unit Price ($m)') + ylab(' Tree Coverage of Public Areas (%)') + geom_point() + labs(caption = "Source: Neosec") +  theme_minimal()


# price_public_plot <- ggplot(house_interactable, mapping = aes(x = average_house_price, y = public_percentage, text = SAL_NAME21, fill = within15, stroke = NA), axe) + xlab('Average Detached House Price ($m)') + ylab(' Tree Coverage of Public Areas (%)') + geom_point() + labs(caption = "Source: Housing Victoria") +  theme_minimal()

rents_public_plot <- (ggplot(sa2_prices %>% filter(property_type == 'HOUSE'), mapping = aes(x = median_band, y = public_percentage, text = sa2_code_2021)) + geom_boxplot(color = "#006D2C") + xlab('Median Rent (2021 dollars)') + ylab("Tree Coverage of Public Areas (%)") +  theme_minimal() + labs(caption = "Source: 2021 Census (ABS)") +  theme(axis.text.x = element_text(angle = 45)) ) 

#bscols(widths = c(4,4), ggplotly(price_street_plot), ggplotly(price_residential_plot))
#subplot(ggplotly(price_street_plot),ggplotly(price_residential_plot), titleY = T, titleX = T)

ggplotly(sa2_public_plot_house)

```

We’ve also split the data into two groups to separate the price premium from proximity to the city and tree courage. These two groupings are:

- Areas within 15 kilometres of the city (blue dots), and 

- Areas outside the 15km range (red dots). 

Performing this split reveals two distinct spatial patterns. For ‘inner’ areas, the relationship between canopy and price is much steeper, while for outer areas, the slope of a best-fit line is much shallower.

#### Unit prices and public tree coverage 

Next, we explore the same relationship but on unit prices. While a positive correlation remains, the divergence between ‘inner’ and ‘outer’ areas does not seem to replicate in unit prices.

```{r}
#| echo: false
ggplotly(sa2_public_plot_unit)
```

#### Rents and public tree coverage

```{r}
#| echo: false
ggplotly(rents_public_plot)

# sal_w_rents <- sal_sf %>%
#   left_join(rents, by = 'SAL_NAME21') %>%
#   arrange(median_band) %>%
#   mutate(median_band = as.factor(median_band))
# 
# cols = brewer.pal(4, 'RdBu' )
# cols = colorRampPalette(cols)(18)
# rentPal =  colorFactor( cols  , domain = sal_w_rents$median_band)

# sal_w_rents %>%
#   leaflet() %>%
#   addProviderTiles('CartoDB.Positron') %>%
#   addPolygons(fillColor = ~rentPal(median_band), fillOpacity = 1, opacity = 0) %>%
#   addLegend(position = "bottomright",
#               pal = rentPal,
#               values =sal_w_rents$median_band,
#               title = 'title')



#plot( house_price_data$median_band, house_price_data$public_percentage)


#colours <- brewer.pal(5, "Set1")
#names(colours) <- levels(house_price_data$direction)

#ggplot(house_price_data, mapping = aes(x = average_house_price, y = residential_percentage, color = direction, text = SAL_NAME21), axe) + xlab('Average House Price ($m)') + ylab('Residential Area Tree Coverage (%)') + geom_point() + scale_color_manual(name = "direction", values = colours) + theme_minimal()


```

The graph above displays the relationship between median rents and public tree coverage. It is not possible to fit a line of best fit, given the categorical nature of rents.

A slight relationship is clear, as median public coverage is increasing with median rents until median rents hit $500. After the $500-524 band, public coverage drops and the relationship no longer holds, although this is mostly due to expensive, urbanised regions located close to the CBD such as Carlton and Fitzroy.

### Tree canopy & urban heat islands

The discussion of tree canopy and equity should not be mistaken for mere politics of envy—rather we must focus on the tangible effect tree canopy coverage has on wellbeing. 

There are few stronger indicators of spatial inequality in our city than the urban heat island effect, which particularly impacts under-serviced areas of Melbourne. 

Combining the Victorian Government's 2018 urban heat dataset with our 2018–20 tree coverage dataset, we sought to determine the relationship between tree coverage and urban temperatures. 

```{r}
#| echo: false

uhi_df = uhi %>%
  st_drop_geometry() %>%
  rename(MB_CODE21 = 'MB_CODE16')

sa1s_downloaded = list.files('../rasters/1res_sa1') %>%
  gsub(".tif", "", .)

if(is_empty(sa1s_downloaded)) {
  sa1s_downloaded = readRDS('../r_objects/sa1s_downloaded.RData')
}

mb = mesh_blocks %>%
  filter(SA1_CODE21 %in% sa1s_downloaded) %>%
  dplyr::select(c(MB_CODE21, SA2_CODE21,  AREASQKM21)) %>%
  left_join(uhi_df, by = 'MB_CODE21') %>%
  st_drop_geometry() %>%
  rowwise() %>%
  mutate(area_anytree = ((PERSHRBTRE)/100) *  AREASQKM21) %>%
  group_by(SA1_MAIN16) %>%
  summarise( total_uhi_cov = sum(area_anytree) / sum(AREASQKM21), uhi = first(UHI18_M), sa2 = first(SA2_CODE21) ) %>%
  rename(sa1 = 'SA1_MAIN16')

sa1_summary <- agg_df %>%
  group_by(sa1) %>%
  filter(zone_short == 'roads') %>%
  summarise( ttl_cov = sum(coverage) / sum(total_area), ttl_cov_a = sum(coverage), ttl_area = sum(total_area)  )

tt <- mb %>%
  left_join(sa1_summary, by = 'sa1') %>% 
  left_join(sa1_sf %>%
  dplyr::select(sa1_code_2021, CHG_FLAG21, SA2_CODE21, AREASQKM21) %>%
  st_drop_geometry() %>%
  rename(sa1 = 'sa1_code_2021'), by = 'sa1') %>%
  mutate(ttl_uhi_cov_a = total_uhi_cov * ttl_area ) %>%
  filter(!is.na(ttl_cov ))

#agg to SA2 and then check diffs? sa1s gonna be noisy regardless

s2_agg <- tt %>% group_by(SA2_CODE21) %>%
  summarise( sa2_cov = sum(ttl_cov_a) / sum(ttl_area), sa2_uhi_cov = sum(ttl_uhi_cov_a) / sum(ttl_area) ) %>%
  mutate(diff = sa2_cov - sa2_uhi_cov)

uhi_plot <- ggplot(tt %>% filter(CHG_FLAG21 == 0), mapping = aes(x = ttl_cov, y = uhi ) ) + 
  geom_point(color = "#006D2C") +
  xlab('Tree Coverage (%)') +
  ylab('Urban Heat Island (deg)') +
  labs(title = "Urban heat island against street tree coverage per SA1") +
  theme_minimal()

ggplotly(uhi_plot)

ts<- feols(uhi ~ ttl_cov, data = tt, vcov = 'hetero')

summary(ts)
# unch = tt %>%
#   filter(CHG_FLAG21 == 0) %>%
#   mutate(diff = ttl_cov - total_uhi_cov) %>%
#   dplyr::select(diff) 
# 
# hist(unlist(unch), xlab = "Difference (Paul - Vic)", main = "Difference between Paul's estimates and Victoria's for each SA1")

```

The above analysis demonstrates a statistically significant correlation between tree canopy coverage and the urban heat island effect—with about 34% of the variation in heat able to be explained by variation in tree canopy coverage.

This will come as no surprise, of course—that areas with no shade are hotter than those without. But trees, the way they cool us, and the other benefits they provide go well beyond shade, and we will discuss each of these key benefits [later in this report](/benefits). 

What is clear, though, is that the distribution of trees across our city is highly inequitable. As Melbourne densifies over the coming years, and more people are empowered to live where they want to live, we must ensure that these people are not shortchanged, and that new dense housing builds have access to a robust urban forest—just like the wealthiest Melburnians currently experience now.

# Increasing street tree coverage while building Melbourne's Missing Middle 

In early 2024 YIMBY Melbourne released its Missing Middle Housing Targets report, which used demand-based modelling to allocate housing targets for each council in metropolitan Melbourne. 

The table below shows the calculations of how much tree canopy coverage might be lost when all the proposed capacity in the upzoned lots is realised and how many street trees would be needed to offset this loss. 


```{r}
#| echo: false
mm_lgas <- c('Brimbank', 'Merri-bek', 'Banyule', 'Darebin', 'Yarra', 'Moonee Valley', 'Manningham', 'Maribyrnong', 'Melbourne', 'Hobsons Bay', 'Port Phillip', 'Boroondara', 'Stonnington', 'Glen Eira', 'Bayside', 'Monash', 'Whitehorse', 'Maroondah', 'Manningham', 'Kingston')


years <- 10

targets <- readRDS('../r_objects/targets.Rdata') %>%
  as.data.frame() %>%
  mutate(Target = sub(',', '', Target))

target_df <- data.frame()

for(lga in targets$LGA) {
  home_target <- as.numeric((targets %>% filter(LGA == lga))$Target) * years
 
  target_df <<- rbind(target_df, c( home_target ,lga_targets(lga, home_target)) ) 
}

colnames(target_df) = c('home_target','LGA', 'coverage_per_sqm', 'lost_coverage', 'initial_coverage', 'final_coverage')

target_df <- target_df %>%
  mutate(across(c('initial_coverage', 'final_coverage', 'lost_coverage'), ~ round(as.numeric(.x) / (10^4), 1) )) %>%
  rowwise() %>%
  mutate(coverage_per_sqm = round(as.numeric(coverage_per_sqm), 3)) %>%
  mutate(percentage_point_change = as.numeric(final_coverage) - as.numeric(initial_coverage),
                                  percentage_change = ((as.numeric(final_coverage)/as.numeric(initial_coverage))-1)*100 ) %>%
  arrange(-percentage_change) %>%
  mutate(percentage_change = round(percentage_change, 3)) %>%
  dplyr::relocate(home_target, .after = LGA)

target_df %>%
  reactable(theme = sandstone(),
            pagination = F,
            columns = list(
              percentage_point_change = colDef(show = F),
              coverage_per_sqm = colDef(show = T, name = "Coverage/M^2 "),
              initial_coverage = colDef(name = "Public Coverage After Targets (Ha)", show = F),
              lost_coverage = colDef(name = "Lost Coverage (Ha)"),
              final_coverage = colDef(name = "Public Coverage To Offset Density  (Ha)"),
              percentage_change = colDef(name = "Percent Growth From Current Public Coverage"),
              home_target = colDef(name = paste0(years,'yr Home Target'))
            ))
```

## Replacing private tree canopy with public tree canopy

Densification is the process of increasing the density on specific lots and building more homes where there is currently, typically, a single detached house. Most of these existing houses are built on lots with relatively large garden areas. Both the Neighbourhood Residential Zone (NRZ) and General Residential Zone (GRZ) have minimum mandated garden areas of 25–35% of the total lot area.

Building Melbourne's Missing Middle will require building dense, six-storey housing on a large number of lots currently zoned NRZ and GRZ. This densification will likely require the removal of existing private tree canopy in order to make way for more homes where people want to live.

But more homes for more Melburnians should not mean fewer trees for those selfsame Melburnians. In fact, Melbourne has the opportunity now to deliver more overall tree canopy, not less, and to deliver it all within public space, for the benefit of everyone. 

Using publicly available tree canopy, planning, and other spatial data, we determine the estimated amount of tree canopy that may be removed from the private realm each year in order to meet our housing targets.

We then [calculate the costs](/costs) of delivering the equivalent canopy within the public realm, providing a clear path to ensuring that a denser Melbourne is also a greener Melbourne, with the [benefits delivered for all](/benefits).

## Street tree canopy is public infrastructure

<TODO: Insert costing table>

To maintain Melbourne's current total tree canopy while densifying Melbourne's missing middle, 57 new trees should be planted per 100 new homes, at a cost of $1,740.15 per dwelling. 

However, we recommend taking this opportunity to not only maintain current canopy levels, but generate an overall increase in coverage across metropolitan Melbourne. 

To generate a meaningful 10% overall increase in mature tree canopy, 62 trees per 100 dwellings should be planted, at a cost of $1,899.45 per dwelling.

This significant urban greening project will have a total cost of $76 million per year. Funding could come from a combination of sources, including developer contributions, government grant programs, and general budgetary expenditure. We expand on this in the [costing section of this report](/costs#paying-for-street-trees).

Finally, we note that all our calculations are based on the delivery of mature tree canopy. This means that the full [benefits](/benefits) of this model will not be delivered immediately, but progressively as trees grow over time. But because public trees within our model are only added and never removed, even upon establishment all new trees planted represent a material benefit for all Melburnians when measured against the status quo. 

The best time to plant a tree was 20 years ago. The second best time is when building more homes where people want to live.






# Interactions with Missing Middle

YM recently released Housing Targets, a data-driven model which allocates housing targets by council.

This page calculates how much tree cover might be lost in the upzoning of residential lots, and then calculating how to offset this loss by increasing coverage of street trees

# Relationships & Additional Plots

This section shows the interaction between public tree coverage and the cost of living in an area, depicted by both detached house prices, the prices of units, and median rents. Public tree coverage is defined as:

$$
 \text{Public tree coverage} = \frac{\text{area of streets covered by trees + area of parks covered by trees}}{\text{area of streets + area of parks}}
$$

Data Note: Rents are using ABS data, which is only available in ranges. Therefore, median rents are defined as whatever bin the median observation falls into. Also note that the Census was in 2021, and therefore rents may be impacted by COVID, and may have changed since. This possibly explains the low rent numbers observed.

House & unit prices are from Neoval.


The above figure displays the relationship between house prices and public tree coverage. There is a tangible correlation between the two variables as SA2s with higher house prices tend to have more public tree coverage. This is not a statement of causation, merely correlation.

The data is further split into two groups: SA2s within 15 kilometres of the city, and SA2s outside the 15km range. This split reveals two distinct spatial patterns.

For 'inner' SA2s, the relationship is much steeper. For outer SA2s, the slope of a best fit line is much shallower.

When looking at unit prices instead of detached homes, a positive pattern remains. However, the divergence between SA2s within 15km and outside of 15km does not seem to replicate in unit prices.

The graph above displays the relationship between median rents and public tree coverage. It is not possible to fit a line of best fit, given the categorical nature of rents.

A slight relationship is clear, as median public coverage is increasing with median rents until median rents hit 500. After the '500-524' band, public coverage drops and the relationship no longer holds, although this is mostly due to expensive regions located close to the CBD such as Carlton and Fitzroy. 

```{r}
#| echo: false
# lot_df = house_price_data %>% filter(med_lot < 2000)
# 
# lotsize_street_plot <- ggplot(lot_df, mapping = aes(x = med_lot, y = street_percentage, text = SAL_NAME21), axe) + xlab('Average Lot Size') + ylab('Street Tree Coverage (%)') + geom_point(color = "#006D2C") + theme_minimal()
# 
# lotsize_residential_plot <- ggplot(lot_df, mapping = aes(x = med_lot, y = residential_percentage, text = SAL_NAME21), axe) + xlab('Average Lot Size') + ylab('Residential Tree Coverage (%)') + geom_point(color = "#006D2C") + theme_minimal()


#ggplotly(lotsize_street_plot)
#ggplotly(lotsize_residential_plot)

#summary(lm(residential_percentage ~ med_lot, house_price_data)) 

#summary(lm(street_percentage ~ med_lot, house_price_data))


#summary(lm(public_percentage ~ med_lot + average_house_price + distance, lot_df))
```
